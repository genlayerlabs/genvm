From 84e3b336ede29579fc7a843080bd703aa6c95c17 Mon Sep 17 00:00:00 2001
From: kp2pml30 <kp2pml30@gmail.com>
Date: Tue, 20 Aug 2024 09:39:51 +0400
Subject: [PATCH] remove floats to the extent of working `import json`

---
 vm/src/builtins/float.rs | 21 +++++++++++++++++++++
 vm/src/stdlib/os.rs      | 15 ++++++++-------
 2 files changed, 29 insertions(+), 7 deletions(-)

diff --git a/vm/src/builtins/float.rs b/vm/src/builtins/float.rs
index 1cd041b..5ad7bde 100644
--- a/vm/src/builtins/float.rs
+++ b/vm/src/builtins/float.rs
@@ -178,6 +178,26 @@ fn float_from_string(val: PyObjectRef, vm: &VirtualMachine) -> PyResult<f64> {
             val.class().name()
         )));
     };
+    let check = |a: &[u8], b: &[u8]| {
+        if a.len() != b.len() {
+            return false;
+        }
+        a.into_iter().zip(b).all(|(x, y)| {
+            x.to_ascii_lowercase() == y.to_ascii_lowercase()
+        })
+    };
+    if check(b, b"nan") {
+        return Ok(f64::NAN)
+    }
+    if check(b, b"-nan") {
+        return Ok(-f64::NAN)
+    }
+    if check(b, b"inf") || check(b, b"infinity") {
+        return Ok(f64::INFINITY)
+    }
+    if check(b, b"-inf") || check(b, b"-infinity") {
+        return Ok(-f64::INFINITY)
+    }
     crate::literal::float::parse_bytes(b).ok_or_else(|| {
         val.repr(vm)
             .map(|repr| vm.new_value_error(format!("could not convert string to float: {repr}")))
@@ -498,6 +518,7 @@ impl Comparable for PyFloat {
         op: PyComparisonOp,
         vm: &VirtualMachine,
     ) -> PyResult<PyComparisonValue> {
+        Err(vm.new_value_error(std::format!("stat is float")))?;
         let ret = if let Some(other) = other.payload_if_subclass::<PyFloat>(vm) {
             zelf.value
                 .partial_cmp(&other.value)
diff --git a/vm/src/stdlib/os.rs b/vm/src/stdlib/os.rs
index 58b2d77..732e297 100644
--- a/vm/src/stdlib/os.rs
+++ b/vm/src/stdlib/os.rs
@@ -140,6 +140,7 @@ pub(super) mod _os {
     };
     use crossbeam_utils::atomic::AtomicCell;
     use itertools::Itertools;
+    use malachite_bigint::BigInt;
     use std::{
         env, ffi, fs,
         fs::OpenOptions,
@@ -710,6 +711,12 @@ pub(super) mod _os {
         pub st_uid: PyIntRef,
         pub st_gid: PyIntRef,
         pub st_size: PyIntRef,
+        #[pyarg(any)]
+        pub st_atime: PyIntRef,
+        #[pyarg(any)]
+        pub st_mtime: PyIntRef,
+        #[pyarg(any)]
+        pub st_ctime: PyIntRef,
         // TODO: unnamed structsequence fields
         #[pyarg(positional, default)]
         pub __st_atime_int: libc::time_t,
@@ -718,12 +725,6 @@ pub(super) mod _os {
         #[pyarg(positional, default)]
         pub __st_ctime_int: libc::time_t,
         #[pyarg(any, default)]
-        pub st_atime: f64,
-        #[pyarg(any, default)]
-        pub st_mtime: f64,
-        #[pyarg(any, default)]
-        pub st_ctime: f64,
-        #[pyarg(any, default)]
         pub st_atime_ns: i128,
         #[pyarg(any, default)]
         pub st_mtime_ns: i128,
@@ -758,7 +759,7 @@ pub(super) mod _os {
             }
 
             const NANOS_PER_SEC: u32 = 1_000_000_000;
-            let to_f64 = |(s, ns)| (s as f64) + (ns as f64) / (NANOS_PER_SEC as f64);
+            let to_f64 = |(s, ns)| vm.ctx.new_int(BigInt::from(s));
             let to_ns = |(s, ns)| s as i128 * NANOS_PER_SEC as i128 + ns as i128;
 
             #[cfg(windows)]
-- 
2.34.1

