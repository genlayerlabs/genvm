// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

use core::fmt;
use core::mem::MaybeUninit;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct Errno(u32);
/// Success
pub const ERRNO_SUCCESS: Errno = Errno(0);
pub const ERRNO_DETERMINISTIC_VIOLATION: Errno = Errno(1);
pub const ERRNO_OVERFLOW: Errno = Errno(2);
pub const ERRNO_INVAL: Errno = Errno(3);
pub const ERRNO_FAULT: Errno = Errno(4);
pub const ERRNO_ILSEQ: Errno = Errno(5);
pub const ERRNO_IO: Errno = Errno(6);
impl Errno {
    pub const fn raw(&self) -> u32 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "SUCCESS",
            1 => "DETERMINISTIC_VIOLATION",
            2 => "OVERFLOW",
            3 => "INVAL",
            4 => "FAULT",
            5 => "ILSEQ",
            6 => "IO",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "Success",
            1 => "",
            2 => "",
            3 => "",
            4 => "",
            5 => "",
            6 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for Errno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Errno")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}
impl fmt::Display for Errno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} (error {})", self.name(), self.0)
    }
}

#[cfg(feature = "std")]
extern crate std;
#[cfg(feature = "std")]
impl std::error::Error for Errno {}

pub type BytesLen = u32;
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct Addr {
    pub ptr: *const u8,
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct FullAddr {
    pub ptr: *const u8,
}
pub type Fd = u32;
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct ResultNow {
    /// The address of the buffer to be written.
    pub file: Fd,
    /// The length of the buffer to be written.
    pub len: BytesLen,
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct Bytes {
    /// The address of the buffer to be written.
    pub buf: *const u8,
    /// The length of the buffer to be written.
    pub buf_len: BytesLen,
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct MutBytes {
    /// The address of the buffer to be written.
    pub buf: *mut u8,
    /// The length of the buffer to be written.
    pub buf_len: BytesLen,
}
pub type None = u32;
pub unsafe fn rollback(message: &str) {
    genlayer_sdk::rollback(message.as_ptr() as i32, message.len() as i32);
}

pub unsafe fn contract_return(result: Bytes) {
    genlayer_sdk::contract_return(&result as *const _ as i32);
}

pub unsafe fn get_message_data() -> Result<ResultNow, Errno> {
    let mut rp0 = MaybeUninit::<ResultNow>::uninit();
    let ret = genlayer_sdk::get_message_data(rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const ResultNow)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn get_entrypoint() -> Result<ResultNow, Errno> {
    let mut rp0 = MaybeUninit::<ResultNow>::uninit();
    let ret = genlayer_sdk::get_entrypoint(rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const ResultNow)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn run_nondet(data_leader: Bytes, data_validator: Bytes) -> Result<Fd, Errno> {
    let mut rp0 = MaybeUninit::<Fd>::uninit();
    let ret = genlayer_sdk::run_nondet(
        &data_leader as *const _ as i32,
        &data_validator as *const _ as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Fd)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn get_webpage(config: &str, url: &str) -> Result<Fd, Errno> {
    let mut rp0 = MaybeUninit::<Fd>::uninit();
    let ret = genlayer_sdk::get_webpage(
        config.as_ptr() as i32,
        config.len() as i32,
        url.as_ptr() as i32,
        url.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Fd)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn call_llm(config: &str, prompt: &str) -> Result<Fd, Errno> {
    let mut rp0 = MaybeUninit::<Fd>::uninit();
    let ret = genlayer_sdk::call_llm(
        config.as_ptr() as i32,
        config.len() as i32,
        prompt.as_ptr() as i32,
        prompt.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Fd)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn call_contract(account: Addr, calldata: Bytes) -> Result<Fd, Errno> {
    let mut rp0 = MaybeUninit::<Fd>::uninit();
    let ret = genlayer_sdk::call_contract(
        &account as *const _ as i32,
        &calldata as *const _ as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Fd)),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn post_message(
    account: Addr,
    calldata: Bytes,
    gas: u64,
    code: Bytes,
) -> Result<(), Errno> {
    let ret = genlayer_sdk::post_message(
        &account as *const _ as i32,
        &calldata as *const _ as i32,
        gas as i64,
        &code as *const _ as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn storage_read(slot: FullAddr, index: u32, buf: MutBytes) -> Result<(), Errno> {
    let ret = genlayer_sdk::storage_read(
        &slot as *const _ as i32,
        index as i32,
        &buf as *const _ as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Errno(ret as u32)),
    }
}

pub unsafe fn storage_write(slot: FullAddr, index: u32, buf: Bytes) -> Result<(), Errno> {
    let ret = genlayer_sdk::storage_write(
        &slot as *const _ as i32,
        index as i32,
        &buf as *const _ as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(Errno(ret as u32)),
    }
}

pub mod genlayer_sdk {
    #[link(wasm_import_module = "genlayer_sdk")]
    extern "C" {
        pub fn rollback(arg0: i32, arg1: i32) -> !;
        pub fn contract_return(arg0: i32) -> !;
        pub fn get_message_data(arg0: i32) -> i32;
        pub fn get_entrypoint(arg0: i32) -> i32;
        pub fn run_nondet(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn get_webpage(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        pub fn call_llm(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        pub fn call_contract(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn post_message(arg0: i32, arg1: i32, arg2: i64, arg3: i32) -> i32;
        pub fn storage_read(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn storage_write(arg0: i32, arg1: i32, arg2: i32) -> i32;
    }
}
